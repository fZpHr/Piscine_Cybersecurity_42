#!/bin/bash

DEBUG=${DEBUG:-0} 
RED='\033[0;31m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
NC='\033[0m'
encrypt_key='42'

debug_print() {
    if [ "$DEBUG" -eq 1 ]; then
        printf "${BLUE}DEBUG: %s${NC}\n" "$1"
    fi
}

is_hex() {
    if ! [[ "$1" == *."hex" ]]; then
        return 1;
    fi
    value=$(cat "$1" | tr -d '\n')
    if [ ${#value} -lt 64 ] || ! [[ $value =~ ^[0-9a-fA-F]+$ ]]; then
        return 1
    fi
    return 0
}

is_crypted() {
    output=$(openssl enc -aes-256-cbc -pbkdf2 -d -in ft_otp.key -pass pass:wrongpassword 2>&1)
    if echo "$output" | grep -q "bad decrypt"; then
        return 0
    elif echo "$output" | grep -q "error reading input file"; then
        printf "${RED}The file $2 is not encrypted with AES-256-CBC.${NC}\n"
        return 1
    else
        printf "${RED}The file $2 is likely not encrypted.${NC}\n"
        return 1
    fi
}

generate_key() {
    if [ -z "$1" ]; then
        printf "${RED}Please provide a hexadecimal key of at least 64 characters${NC}\n"
        exit 1
    fi

    key_content="$1"
    if is_hex "$key_content"; then
        echo -n "$key_content" | openssl enc -aes-256-cbc -pbkdf2 -salt -out ft_otp.key -pass pass:${encrypt_key}
        printf "${GREEN}Key stored securely in ft_otp.key${NC}\n"
    else
        printf "${RED}Key is not in hex format or is too short${NC}\n"
        exit 1
    fi
}

generate_random_key() {
    if [ -z "$1" ]; then
        printf "${RED}Please provide the name of the key${NC}\n"
        exit 1
    fi

    openssl rand -hex 32 | tr -d '\n' > "$1.hex"
    printf "${GREEN}Key generated and saved in $1.hex${NC}\n"
}

generate_otp() {
    if [ "$1" != "ft_otp.key" ]; then
        printf "${RED}Please generate the key with -g or provide the key name ft_otp.key${NC}\n"
        exit 1
    fi

    if [ ! -f "$1" ]; then
        printf "${RED}Encrypted key file ft_otp.key not found${NC}\n"
        exit 1
    fi

    if ! is_crypted; then
        printf "${RED}The file $1 is not generated by this script${NC}\n"
        exit 1
    fi

    key_file=$(openssl enc -aes-256-cbc -pbkdf2 -d -in "$1" -pass pass:${encrypt_key} | tr -d '\n')
    key=$(cat $key_file | tr -d '\n')
    debug_print "Key used: $key"
    debug_print "Key length: ${#key}"
    
    if [ -z "$key" ]; then
        printf "${RED}Failed to decrypt the key${NC}\n"
        exit 1
    fi
    if is_hex "$key"; then
        printf "${RED}Decrypted key is not in hex format${NC}\n"
        exit 1
    fi

    # # HOTP algorithm (RFC 4226) : https://tools.ietf.org/html/rfc4226 (page 6) | ./ft_otp.sh -g test.hex && DEBUG=1 ./ft_otp.sh -k ft_otp.key && oathtool --totp --verbose $(cat test.hex) 
    # count_file="hotp_counter"
    # if [ ! -f "$count_file" ]; then
    #     echo 0 > "$count_file"
    # fi

    # count=$(cat "$count_file")
    # ((count++))
    # echo $count > "$count_file"

    debug_print "Counter value for HOTP algo: $count"
    time_step=30
    count+=$(( $(date +%s) / $time_step ))
    debug_print "Current Unix time: $count"
    debug_print "Step size: $time_step"
    debug_print "T value: $count"
    debug_print "Counter value after adding minutes TOTP logic: $count"
    
    hex_count=$(printf "%016x" $count)
    debug_print "Format counter value in hex for HMAC-SHA1: $hex_count"
    
    hmac=$(printf "%016x" $count | xxd -r -p | openssl dgst -sha1 -mac HMAC -macopt hexkey:$key | sed 's/^.* //')
    debug_print "HMAC-SHA1 (key + counter): $hmac"

    offset=$((0x${hmac: -1} & 0xf))
    debug_print "Keep the last 4 bits of the HMAC-SHA1 -> Offset: $offset"

    debug_print "Dynamic truncation at offset $offset:"
    debug_print "  First byte:  0x${hmac:$((offset*2)):2} & 0x7f"
    debug_print "  Second byte: 0x${hmac:$((offset*2+2)):2} & 0xff"
    debug_print "  Third byte:  0x${hmac:$((offset*2+4)):2} & 0xff"
    debug_print "  Fourth byte: 0x${hmac:$((offset*2+6)):2} & 0xff"

    #exemple : 
        #offset 9
        # bccb3f81b1611ca8c7f8ac12e0727c65078805e9
        #  offset*2         ^position 18
        # 4 octet a partir de l'offeset : f8ac12e0
        # application de l'opération logique sur chaque octet :
            # f8 = 11111000  
            # 7f = 01111111  
            # f8 & 7f = 01111000 (hex = 78)
            #    zf8 & 0x7f = 78  << 24 = 78000000
            # ac = 10101100
            # ff = 11111111
            # ac & ff = 10101100 (hex = ac)
            #    Deuxième : ac & 0xff = ac  << 16 = 00ac0000
            # 12 = 00010010  
            # ff = 11111111 
            # 12 & ff = 00010010 (hex = 12)
            #    Troisième: 12 & 0xff = 12  << 8  = 00001200
            # e0 = 11100000  
            # ff = 11111111  
            # e0 & ff = 11100000 (hex = e0)
            #    Quatrième: e0 & 0xff = e0        = 000000e0
        # combinaison avec | (OR) : 78000000 | 00ac0000 | 00001200 | 000000e0 = 78ac12e0 -> 2024460000 % 1000000 = 460000
    bin_code=$(( ((0x${hmac:$((offset*2)):2} & 0x7f) << 24 ) | \
                ((0x${hmac:$((offset*2+2)):2} & 0xff) << 16 ) | \
                ((0x${hmac:$((offset*2+4)):2} & 0xff) << 8 ) | \
                (0x${hmac:$((offset*2+6)):2} & 0xff) ))
    debug_print "Binary code: $bin_code"

    bin_code=$((bin_code & 0x7fffffff))
    debug_print "31-bit string: $bin_code"

    hotp=$((bin_code % 1000000))
    debug_print "HOTP value: $hotp"

    printf "${GREEN}%06d\n" $hotp
}

if [ "$#" -gt 2 ]; then
    printf "${RED}Too many arguments${NC}\n"
    exit 1
fi

case "$1" in
    -g)
        generate_key "$2"
        ;;
    -n)
        generate_random_key "$2"
        ;;
    -k)
        generate_otp "$2"
        ;;
    *)
        printf "${BLUE}Possible options are:   -n : Generate a new key 64 hex characters\n"
        printf "                        -g : Encrypt the key\n"
        printf "                        -k : Generate a new temporary key${NC}\n"
        ;;
esac
